# MockMAVL

A handy generator to create lots of meaningless, but syntactically and semantically correct MAVL programs.

## What's MAVL?

MAVL is short for _Matrix and Vector Language_ - it's a java-like programming language built to teach concepts of compilers and programming languages at TU Darmstadt. MockMAVL specifically was designed to generate programs in the 2018 flavour of MAVL, although the differences to other versions should be rather small.

## Usage

`ruby mockMAVL.rb [options]`  

Options:  
`--pretty` "pretty" print, tries to insert some newlines and performs minor whitespace cleanup  
`--maxdim=6` Set maximum vector and matrix dimension  
`--help` (`-h`) Show help and exit  

## Sample Output

A program generated by MockMAVL might look something like this:

```
function void applyChanges(bool storageEnabled) {
	var vector <int> [1 * 2 - 0] shiftVector;
	val int processDepth = processDepth - 734;
	switch (542) {
		case 86 : foreach(val int n : false ? [[147, 575]] : [[568, 794]]) {
			storageEnabled = false & true | false;
		}
		case 94 : var matrix <int> [2][2] translationMatrix;
		case 102 : val float y = y;
		case 110 : var matrix <int> [10 / 5][1 * (2)] bitMatrix;
		case 10 + 108 / 1 : val int res = res;
	}
	if (storageEnabled | storageEnabled | true)
		val int k = 851;
}

function void callExternal(vector <float> [1 * 15 - 14] scaleArray, int systemCounter) {
	{
		foreach(val float dataFlt : false | true ? scaleArray +(8.05963 - 0.30995) + [1.5] : scaleArray) applyChanges(false);
		val string serviceValue = "127.0.0.1";
		if (true) switch (142) {
			default : foreach(val float cosValue : scaleArray) val vector <float> [1] scaleVector = [11.27454];
			case 3 + 48 - 6 : val vector <float> [2] scaleList = [1.5, 1.5];
			case 1 * 2 * 24 : {
				for(systemCounter = 588; false | false; systemCounter = 736) val matrix <int> [2][(10 - 1 * 9) + 0] translationMatrix = [[92], [606]] - systemCounter * translationMatrix ^ translationMatrix ^ [127, 590] [systemCounter] - translationMatrix;
				{
					for(scaleArray = 3.94401 + [1.5]; true; scaleArray = 7.33555 + [1.5] * [[14.2357 + 8.92736 + 16.49566 * - scaleArray [false ? systemCounter - 212 : 367] ^ [true ? 2.25431 - 6.97724 : 5.10375, 1.5] {0 : systemCounter - 457 : 0} / 0.32061], [0.56416]][systemCounter] * [18.70191 - 9.30231]) {	
					}
					if (true) var float preciseValue;
					else var string queryType;
					applyChanges(false | false);
				}
			}
		}
	}
	val matrix <int> [1 * 1][2] transformationMatrix = false ? [[99, 77]] : systemCounter + [[869, 908]] * [[991, 617]] ^ transformationMatrix - [[215, 607]];
}

function void callVisitor() {}

function void main() {
	var bool canLoad;
	var int systemAmount;
	for(systemAmount = 692; canLoad | canLoad ? canLoad & canLoad & canLoad |! canLoad & true | canLoad : true; systemAmount = 452) {
		switch (578 - systemAmount / [930] # [76]) {
			
		}
		var bool canRead;
		foreach(val float sinValue : [1.5, 1.5]) systemAmount = 800 + systemAmount / [257] .dimension;
		
	}
	var matrix <float> [(10 / 5)][1] transformationField;
	var float sinAmount;
}

```